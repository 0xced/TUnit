using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Engine.SourceGenerator.Extensions;
using TUnit.Engine.SourceGenerator.Models;

namespace TUnit.Engine.SourceGenerator.CodeGenerators;

/// <summary>
/// A sample source generator that creates C# classes based on the text file (in this case, Domain Driven Design ubiquitous language registry).
/// When using a simple text file as a baseline, we can create a non-incremental source generator.
/// </summary>
[Generator]
public class TestsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        if (!Debugger.IsAttached)
        {
            // Debugger.Launch();
        }

        var testMethods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(
            testMethods,
            static (productionContext, methods) => Execute(productionContext, methods)
        );
    }

    static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax;
    }

    static IEnumerable<ClassMethod> GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        if (context.Node is not ClassDeclarationSyntax)
        {
            yield break;
        }

        var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);

        if (symbol is not INamedTypeSymbol namedTypeSymbol)
        {
            yield break;
        }

        if (namedTypeSymbol.IsAbstract)
        {
            yield break;
        }

        var methods = namedTypeSymbol
            .GetMembersIncludingBase()
            .OfType<IMethodSymbol>()
            .Where(x => x.MethodKind != MethodKind.Constructor);

        foreach (var methodSymbol in methods)
        {
            var attributes = methodSymbol.GetAttributes();

            if (!attributes.Any(x => x.AttributeClass?.IsTestClass() == true))
            {
                continue;
            }

            yield return new ClassMethod(namedTypeSymbol, methodSymbol);
        }
    }

    private static void Execute(SourceProductionContext context, IEnumerable<ClassMethod> classMethods)
    {
        foreach (var classMethod in classMethods)
        {
            var className = $"{classMethod.MethodSymbol.Name}_{Guid.NewGuid():N}";

            var classSource = ProcessTests(classMethod, className);
                
            if (string.IsNullOrEmpty(classSource))
            {
                continue;
            }

            context.AddSource($"{className}.g.cs", classSource);
        }
    }

    private static string? ProcessTests(ClassMethod classMethod, string className)
    {
        var writeableTests = WriteableTestsRetriever.GetWriteableTests(classMethod);

        if (!writeableTests.Any())
        {
            return null;
        }
        
        using var sourceBuilder = new SourceCodeWriter();

        sourceBuilder.WriteLine("// <auto-generated/>");
        sourceBuilder.WriteLine("using System.Linq;");
        sourceBuilder.WriteLine("using System.Reflection;");
        sourceBuilder.WriteLine("using System.Runtime.CompilerServices;");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine("namespace TUnit.Engine;");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine($"file class {className}");
        sourceBuilder.WriteLine("{");
        sourceBuilder.WriteLine("[ModuleInitializer]");
        sourceBuilder.WriteLine("public static void Initialise()");
        sourceBuilder.WriteLine("{");

        WriteTestInvocationCode(sourceBuilder, writeableTests);

        sourceBuilder.WriteLine("}");
        sourceBuilder.WriteLine("}");

        return sourceBuilder.ToString();
    }

    private static void WriteTestInvocationCode(SourceCodeWriter sourceBuilder, IEnumerable<WriteableTest> writeableTests)
    {
        foreach (var writeableTest in writeableTests)
        {
            GenericTestInvocationGenerator.GenerateTestInvocationCode(sourceBuilder, writeableTest);
        }
    }
}

public record ClassMethod(INamedTypeSymbol NamedTypeSymbol, IMethodSymbol MethodSymbol);