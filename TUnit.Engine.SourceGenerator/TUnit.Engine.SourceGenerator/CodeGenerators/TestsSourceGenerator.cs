using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TUnit.Engine.SourceGenerator.Models;

namespace TUnit.Engine.SourceGenerator.CodeGenerators;

/// <summary>
/// A sample source generator that creates C# classes based on the text file (in this case, Domain Driven Design ubiquitous language registry).
/// When using a simple text file as a baseline, we can create a non-incremental source generator.
/// </summary>
[Generator]
public class TestsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var testMethods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s), 
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Collect();
            
        context.RegisterSourceOutput(testMethods, Execute);
    }
    
    static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax { AttributeLists.Count: > 0 } methodDeclarationSyntax;
    }

    static Method? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        if (context.Node is not MethodDeclarationSyntax methodDeclarationSyntax)
        {
            return null;
        }
        
        var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);
        
        if (symbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        var attributes = methodSymbol.GetAttributes();

        if (!attributes.Any(x =>
                x.AttributeClass?.BaseType?.ToDisplayString(DisplayFormats.FullyQualifiedGenericWithGlobalPrefix)
                == WellKnownFullyQualifiedClassNames.BaseTestAttribute))
        {
            return null;
        }

        return new Method(methodDeclarationSyntax, methodSymbol);
    }
    
    private static void Execute(SourceProductionContext context, ImmutableArray<Method?> methods)
    {
        foreach (var method in methods.OfType<Method>())
        {
            var classSource = ProcessTests(method);
                
            if (string.IsNullOrEmpty(classSource))
            {
                continue;
            }

            var className = $"{method.MethodSymbol.Name}_{Guid.NewGuid():N}";
            context.AddSource($"{className}.g.cs", SourceText.From(WrapInClass(className, classSource), Encoding.UTF8));
        }
    }

    private static string WrapInClass(string className, string methodCode)
    {
        return $$"""
               // <auto-generated/>
               using System.Linq;
               using System.Runtime.CompilerServices;

               namespace TUnit.Engine;

               file class {{className}}
               {
                   [ModuleInitializer]
                   public static void Initialise()
                   {
                        {{methodCode}}
                   }
               } 
               """;
    }

    private static string ProcessTests(Method method)
    {
        var methodSymbol = method.MethodSymbol;
        
        if (methodSymbol.ContainingType.IsAbstract)
        {
            return string.Empty;
        }

        var sourceBuilder = new StringBuilder();
        
        AttributeData[] attributes =
        [
            ..methodSymbol.GetAttributes(),
            ..methodSymbol.ContainingType.GetAttributes()
        ];
        
        var repeatCount = attributes
            .FirstOrDefault(x =>
                x.AttributeClass?.ToDisplayString(DisplayFormats.FullyQualifiedNonGenericWithGlobalPrefix) ==
                WellKnownFullyQualifiedClassNames.RepeatAttribute)
            ?.ConstructorArguments
            .FirstOrDefault()
            .Value as int? ?? 0;

        // +1 for the initial non-repeated run
        for (var i = 1; i <= repeatCount + 1; i++)
        {
            foreach (var attributeData in attributes)
            {
                foreach (var classInvocation in ClassInvocationsGenerator.GenerateClassInvocations(methodSymbol.ContainingType))
                {
                    var testInvocationCode = GetTestInvocationCode(attributeData, sourceBuilder, methodSymbol, classInvocation, i);
                    sourceBuilder.AppendLine(testInvocationCode);
                }
            }
        }

        return sourceBuilder.ToString();
    }

    private static string GetTestInvocationCode(AttributeData attributeData, StringBuilder sourceBuilder,
        IMethodSymbol methodSymbol, ClassInvocationString classInvocation, int i)
    {
        return attributeData.AttributeClass?.ToDisplayString(DisplayFormats.FullyQualifiedNonGenericWithGlobalPrefix)
            switch
            {
                "global::TUnit.Core.TestAttribute" => BasicTestInvocationGenerator.GenerateTestInvocationCode(methodSymbol, classInvocation, [], i),
                "global::TUnit.Core.DataDrivenTestAttribute" => "// TODO: Not yet implemented",
                "global::TUnit.Core.DataSourceDrivenTestAttribute" => "// TODO: Not yet implemented",
                "global::TUnit.Core.CombinativeTestAttribute" => "// TODO: Not yet implemented",
                _ => "// TODO: Not yet implemented"
            };
    }
}