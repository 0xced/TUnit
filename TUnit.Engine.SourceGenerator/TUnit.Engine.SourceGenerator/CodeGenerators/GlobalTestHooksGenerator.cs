using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Engine.SourceGenerator.CodeGenerators.Helpers;
using TUnit.Engine.SourceGenerator.Enums;
using TUnit.Engine.SourceGenerator.Models;

namespace TUnit.Engine.SourceGenerator.CodeGenerators;


[Generator]
internal class GlobalTestHooksGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var testMethods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(testMethods, Execute);
    }

    static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    static GlobalTestHooksDataModel? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        if (context.Node is not MethodDeclarationSyntax)
        {
            return null;
        }

        var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);

        if (symbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        if (!methodSymbol.IsStatic)
        {
            return null;
        }

        var attributes = methodSymbol.GetAttributes();

        var hookType = HookType.None;
        
        foreach (var attributeData in attributes)
        {
            var displayString = attributeData.AttributeClass?.ToDisplayString(
                DisplayFormats.FullyQualifiedNonGenericWithGlobalPrefix);

            if (displayString is WellKnownFullyQualifiedClassNames.GlobalBeforeEachTestAttribute)
            {
                hookType |= HookType.SetUp;
            }
            
            if (displayString is WellKnownFullyQualifiedClassNames.GlobalAfterEachTestAttribute)
            {
                hookType |= HookType.CleanUp;
            }
        }
        
        if (hookType == HookType.None)
        {
            return null;
        }

        return new GlobalTestHooksDataModel
        {
            HookType = hookType,
            MethodName = methodSymbol.Name,
            FullyQualifiedTypeName = methodSymbol.ContainingType.ToDisplayString(DisplayFormats.FullyQualifiedGenericWithGlobalPrefix),
            MinimalTypeName = methodSymbol.ContainingType.Name,
            KnownArguments = GetKnownArguments(methodSymbol.Parameters)
        };
    }

    private static KnownArguments GetKnownArguments(ImmutableArray<IParameterSymbol> methodSymbolParameters)
    {
        if (methodSymbolParameters.IsDefaultOrEmpty)
        {
            return KnownArguments.None;
        }

        var knownArguments = KnownArguments.None;

        foreach (var displayString in methodSymbolParameters.Select(parameter => parameter.Type.ToDisplayString(DisplayFormats.FullyQualifiedNonGenericWithGlobalPrefix)))
        {
            if (displayString == WellKnownFullyQualifiedClassNames.TestContext)
            {
                knownArguments |= KnownArguments.TestContext;
            }
        
            if (displayString == "global::System.Threading.CancellationToken")
            {
                knownArguments |= KnownArguments.CancellationToken;
            }
        }

        return knownArguments;
    }

    private void Execute(SourceProductionContext context, GlobalTestHooksDataModel? model)
    {
        if (model is null)
        {
            return;
        }
        
        var className = $"GlobalTestHooks_{model.MinimalTypeName}_{Guid.NewGuid():N}";

        using var sourceBuilder = new SourceCodeWriter();
                
        sourceBuilder.WriteLine("// <auto-generated/>");
        sourceBuilder.WriteLine("using System.Linq;");
        sourceBuilder.WriteLine("using System.Reflection;");
        sourceBuilder.WriteLine("using System.Runtime.CompilerServices;");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine("namespace TUnit.Engine;");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine($"file GlobalTest {className}");
        sourceBuilder.WriteLine("{");
        sourceBuilder.WriteLine("[ModuleInitializer]");
        sourceBuilder.WriteLine("public static void Initialise()");
        sourceBuilder.WriteLine("{");

        if (model.HookType.HasFlag(HookType.SetUp))
        {
            sourceBuilder.WriteLine(
                $"global::TUnit.Engine.GlobalTestHookOrchestrator.RegisterSetUp(() => global::TUnit.Core.Helpers.RunHelpers.RunAsync(() => {model.FullyQualifiedTypeName}.{model.MethodName}{MethodParenthesisRetriever.WriteParenthesis(model.KnownArguments)}));");
        }

        if (model.HookType.HasFlag(HookType.CleanUp))
        {
            sourceBuilder.WriteLine(
                $"global::TUnit.Engine.GlobalTestHookOrchestrator.RegisterCleanUp(() => global::TUnit.Core.Helpers.RunHelpers.RunAsync(() => {model.FullyQualifiedTypeName}.{model.MethodName}{MethodParenthesisRetriever.WriteParenthesis(model.KnownArguments)}));");
        }

        sourceBuilder.WriteLine("}");
        sourceBuilder.WriteLine("}");

        context.AddSource($"{className}.g.cs", sourceBuilder.ToString());
    }
}